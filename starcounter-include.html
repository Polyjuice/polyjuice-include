<!--
`starcounter-include` -
Custom Element (w/ Polymer's TemplateBinding)
with predefined template content, which should be used to include partials.
It's just <template is="imported-template"> wrapped within Shadow Root for `declarative-shadow-dom` bindable by layout editor.
Uses Shadow DOM given from DB as `Starcounter.MergedPartial.(CompositionProvider|CompositionProvider_0).Composition$`.
version: 3.0.0-rc.8

-->
<!-- Import dependencies -->
<link rel="import" href="../imported-template/imported-template.html">
<link rel="import" href="../translate-shadowdom/translate-shadowdom.html">
<!-- <link rel="import" href="/sys/console-log/console-log.html"> -->

<script>
    (function() {
        const isWebkit = navigator.vendor && navigator.vendor.indexOf("Apple") > -1;
        
        // still needed for .selectNode
        const isSafari = isWebkit && navigator.userAgent && !navigator.userAgent.match("CriOS");

        const useShadowDOMV1 = !isWebkit && Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);
        // && !(window.StarcounterInclude && window.StarcounterInclude.shadow === 'v0'));
        const defaultShadowCSS = '<style>:host{display:block;}</style>';
        const defaultShadowDOM = useShadowDOMV1 ? '<slot></slot>' : '<content select=":not([slot]),[slot=\'\']"></content>';


        class StarcounterInclude extends HTMLElement {
            // static get shadow(){
            //     return useShadowDOMV1;
            // }
            static get observedAttributes() {
                return ['partial', 'view-model', 'partialId'];
            }
            // the self argument might be provided or not
            // in both cases, the mandatory `super()` call
            // will return the right context/instance to use
            // and eventually return
            createdCallback() {
                this.createComponent();
                const partialAttrib = this.getAttribute('partial');
                const viewModelAttrib = this.getAttribute('view-model');
                partialAttrib && this.attributeChangedCallback('partial', null, partialAttrib);
                viewModelAttrib && this.attributeChangedCallback('view-model', null, viewModelAttrib);
            }
            /**
             * Stamp `imported-template` into Light DOM,
             * attach `stamping` listener to gather Shadow DOM layout compositions
             * (declarative-shadow-dom)
             */
            stampImportedTemplate(){
                if(!this.template){
                    const starcounterInclude = this;
                    this.defaultComposition = null;
                    const importedTemplate = document.createElement('template', 'imported-template');

                    importedTemplate.addEventListener('stamping', function fetchCompositions(event) {
                        var mergedComposition = null;
                        var templates = event.detail.querySelectorAll('template[is="declarative-shadow-dom"],template[is="starcounter-composition"]');
                        if(templates.length){
                            mergedComposition = document.createDocumentFragment()
                            Array.prototype.forEach.call(templates, function mergeContents(individualComposition) {
                                if(individualComposition.getAttribute('is') === 'starcounter-composition'){
                                    console.warn('`starcounter-composition` was renamed to `declarative-shadow-dom`! Please update your markup, as the old name is likely to be not supported soon (in V1).')
                                }
                                mergedComposition.appendChild(individualComposition.content.cloneNode(true));
                            });
                        }
                        starcounterInclude.defaultComposition = mergedComposition;

                        if (this.model != starcounterInclude.partial) {
                            this.model = starcounterInclude.partial
                        }
                        // notify composition property
                        // TODO: consider moving entire partialChanged or appendChild here
                        starcounterInclude._compositionChanged();
                    });

                    this.appendChild(importedTemplate);
                    this.template = importedTemplate;
                }
            }
            attachedCallback(){
                this.stampImportedTemplate();
            }
        }
        var StarcounterIncludePrototype = StarcounterInclude.prototype;
        StarcounterIncludePrototype.shadow = useShadowDOMV1;
        StarcounterIncludePrototype.partial = null;
        StarcounterIncludePrototype.partialId = null;
        // StarcounterIncludePrototype.href = null;
        StarcounterIncludePrototype.mergedHtmlPrefix = '/sc/htmlmerger?';
        StarcounterIncludePrototype.defaultHtml = '';
        /**
         * @see Starcounter/starcounter-include - partialAttributeToProperty It's just a copy
         */
        function partialAttributeToProperty(element, attrVal) {

            var attrVal = element.getAttribute("partial") || element.getAttribute("view-model");
            if(!attrVal){
                // no value
                return undefined;
            } else if (attrVal.match(/\{\{.*\}\}|\[\[.*\]\]/)) {
                return null;
            } else {
                return JSON.parse(attrVal);
            }
        }
        /**
         * Create shadowRoot, define property setters, set unitial partial.
         */
        StarcounterIncludePrototype.createComponent = function StarcounterIncludeCreated() {
            var starcounterInclude = this;
            this.defaultComposition = null;
            var partialId = this.partialId;
            var partial = this.viewModel || this.partial || undefined;
            checkForNonNamespaced(partial, this);

            // build shadow DOM
            if(useShadowDOMV1){
                this.attachShadow({mode: "open"});
            } else {
                this.createShadowRoot();
            }
            // partialChanged will do
            // this.stampComposition();

            // define a setter for partial attribute,
            // so it could be change by VanillaJs without Polymer Template Binding
            Object.defineProperties(this, {
                partial: {
                    set: function(newValue) {
                        partial = newValue;
                        checkForNonNamespaced(partial, this);
                        starcounterInclude.stampImportedTemplate();
                        starcounterInclude.partialChanged(partial);
                    },
                    get: function() {
                        return partial;
                    }
                },
                viewModel: {
                    set: function(newValue) {
                        this.partial = newValue;
                    },
                    get: function() {
                        return this.partial;
                    }
                },
                partialId: {
                    set: function(newValue) {
                        // do nothing if value is the same or null is being changed to undefined
                        if (newValue != partialId) {
                            partialId = newValue || null;
                            if (!partialId) {
                                this.removeAttribute("partial-id");
                            } else {
                                this.setAttribute("partial-id", partialId);
                            }
                        }
                    },
                    get: function() {
                        return partialId;
                    }
                }
            });
            // attach partial
            this.partialChanged();
        };
        /**
         * Set partial property if partial or viewm-model attribute was changed
         */
        StarcounterIncludePrototype.attributeChangedCallback = function(name, oldVal, newVal) {
            if (name === "partial" || name === "view-model") {
                this.partial = partialAttributeToProperty(this, newVal);
                //d console.log("starcounter-partial attr changed");
            }
        };
        /**
         * Updates inner `imported-template` with partial data given (if applicable)
         * @see Starcounter/starcounter-include#partialChanged it's alsmost a copy
         * @param  {Object} newVal new partial value
         */
        StarcounterIncludePrototype.partialChanged = function(newVal) {
            this._htmlChanged();
            this._compositionChanged();
        };
        StarcounterIncludePrototype._htmlChanged = function() {
            // do nothing if there is no tempalte yet
            if(!this.template){
                return;
            }
            var href = buildURL(this.partial, this.mergedHtmlPrefix, this.defaultHtml);
            if (href !== this.template.href) {
                if (this.template.href) {
                    this.template.clear();
                }
                if (!href) {
                    this.template.href = null;
                    if (this.template.model != this.partial) {
                        this.template.model = this.partial
                    }
                } else {
                    this.template.href = href;
                }
            } else if (this.template.model != this.partial) {
                this.template.model = this.partial
            }
        };

        /**
         * Stamps composition if needed
         * @param  {String|DocumentFragment} compositionRef reference to the evaluated composition
         * @param  {Function} callb Function that returns a composition to render
         */
        StarcounterIncludePrototype._renderCompositionChange = function(compositionRef, callb) {
            if (this._forceLayoutChange || this._lastCompositionRef !== compositionRef) {
                let composition = callb();
                if (composition !== false) { //it might be undefined and that's a valid value
                    this._forceLayoutChange = false;
                    this.stampComposition(composition);
                    this._lastCompositionRef = compositionRef;
                }
            }
        }        

        function appendComposition(fragment, template) {
            if (template.nodeName && template.nodeName == 'TEMPLATE') {
                const name = template.getAttribute('is');
                if (name === 'declarative-shadow-dom' || name === 'starcounter-composition') {
                    if (name === 'starcounter-composition') {
                        console.warn('`starcounter-composition` was renamed to `declarative-shadow-dom`! Please update your markup, as the old name is likely to be not supported soon (in V1).')
                    } 
                    fragment.appendChild(template.content.cloneNode(true));
                }
            }
        }        

        /**
         * Handles change of the composition.
         * If not given explicitely, fetches one from provider.
         * If not given in provider, fetches one from imported template's default composition.
         * If imported template does not have a default composition, uses fallback composition.
         * Warning: the explicit composition might come from https://github.com/Starcounter/starcounter-layout-html-editor/blob/17b21f729facd9a8dcd4241fb5c48cb71de11af5/starcounter-layout-html-editor.html#L253
         * @see .stampComposition
         * @param  {String} compositionString stringified HTML for new Shadow Root
         */
        StarcounterIncludePrototype._compositionChanged = function(compositionString) {
            if (compositionString) {
                this._forceLayoutChange = true;
                return this._renderCompositionChange("explicit or fallback", () => this.stringToDocumentFragment(compositionString));
            }
            else {
                const compositionProvider = this.partial && findCompositionProvider(this.partial);

                if (compositionProvider) {
                    this.partialId = compositionProvider.PartialId;
                    if (compositionString === "") {
                        //this is a request from starcounter-layout-html-editor to reset to default composition
                        this.Composition$ = "";
                    }
                    else if (compositionProvider.Composition$) {
                        return this._renderCompositionChange(compositionProvider.Composition$, () => {
                            this.storedLayout = compositionProvider.Composition$; //should always be string
                            const merged = this.stringToDocumentFragment(this.storedLayout);

                            if (compositionProvider.ViewUris) {
                                const keys = Object.keys(this.partial);
                                for(let key of keys) {
                                    const scoped = this.partial[key];
                                    if (scoped && scoped.Html && compositionProvider.ViewUris.indexOf(scoped.Html) === -1) {
                                        if (this.defaultComposition) {
                                            this.template.scopedNodes.forEach((nodes) => {
                                                if(nodes.scope === key) {
                                                    nodes.forEach((node) => appendComposition(merged, node));
                                                }
                                            });
                                        }
                                        else {
                                            return false;
                                        }
                                    }
                                }
                            }

                            return merged;
                        });
                    }
                }
                else {
                    this.partialId = null;
                }

                if (this.defaultComposition) {
                    return this._renderCompositionChange(this.defaultComposition, () => this.defaultComposition.cloneNode(true));
                }
                
                return this._renderCompositionChange("explicit or fallback", () => undefined);
            }            
        };
        /**
         * Forward Polymer notification downwards from `<template is="dom-bind">`
         * to <template is="imported-template">
         * @param  {String} path Polymer notification path
         * @param  {Mixed} value New value
         */
        StarcounterIncludePrototype._notifyPath = function(path, value) {
            var sameModelAlreadyLoaded = this.template.model == this.partial;
            this.partialChanged(this.partial);
            if (sameModelAlreadyLoaded && this.template._notifyPath) {
                this.template._notifyPath(
                    path.replace("partial.", "model.")
                        .replace("viewModel.", "model."),
                     value);
            }
        };
        /**
         * Retrieves URL of HTML file to be loaded from given partial.
         * For merged partials/namespaced JSONs without
         * `.Html` property on root level it builds one out of
         * `.Html` properties from nested objects
         * {prefix}{key1}={partial.key1.Html}&{key2}={partial.key2.Html}&{key3}={defaultURL}
         * Parameters are URI encoded, for scopes without `.Html` property _defaultURL_ is used
         * @param  {Object} partial    partial object
         * @param  {String} prefix     prefix for merged partials
         * @param  {String} defaultURL Html to be used for nodes that does not have one
         * @return {String}            [description]
         */
        function buildURL(partial, prefix, defaultURL) {
            if(partial){
                if(partial.Html !== undefined){
                    return partial.Html;
                } else {
                    var htmls = [];
                    for (var key in partial){
                        if (partial.hasOwnProperty(key)) {
                            // quick fix for https://github.com/Starcounter/starcounter-include/issues/37
                            // just to unblock https://github.com/Starcounter/level1/issues/4061
                            if (key !== '_ver#s' && key !== '_ver#c$') {
                                htmls.push(
                                    encodeURIComponent(key) +
                                    '=' +
                                    (partial[key].Html && encodeURIComponent(partial[key].Html) || defaultURL)
                                );
                            }
                        }
                    }
                    // Workaround for https://github.com/Starcounter/Starcounter/issues/3072
                    // as described in https://github.com/Starcounter/starcounter-include/issues/12
                    return htmls.length && (prefix + htmls.join('&')) || undefined;
                    // return prefix + htmls.join('&');
                }
            } else {
                return undefined;
            }
        };
        /**
         * Saves given or current composition as stored one, (TODO:) notifies binding about it.
         * @param  {String} [compositionStr] composition to be saved, if not given current one will be used
         * @TODO: to be simplified after https://github.com/StarcounterApps/CompositionProvider/pull/13 is done
         */
        StarcounterIncludePrototype.saveLayout = function(compositionStr){
            compositionStr = compositionStr || this.shadowRoot.innerHTML;
            findCompositionProvider(this.partial).Composition$ = compositionStr;
            setTimeout(() => {
                this._compositionChanged(); //ugly hack for JSONPatcherProxy notifying Polymer before the new value is applied on the actual object (https://github.com/Palindrom/JSONPatcherProxy/blob/master/src/jsonpatcherproxy.js#L164). In result, I get _notifyPath in s-e with the old value! Repro: 1) comment out this setTimeout, 2) Reset compositions, 3) save a new composition in CompositionEditor, 4) see that it resets to default on saving
            }, 1);
            this.dispatchEvent(new CustomEvent("starcounter-include-composition-saved", {detail: compositionStr}));
            // trigger polymer-notification-protocol-compilant event
            var notificationPath = findCompositionProviderPath(this.partial) + '.Composition$';
            this.dispatchEvent(new CustomEvent("partial-changed", {detail: {value: compositionStr, path: 'partial.' + notificationPath}}));
            this.dispatchEvent(new CustomEvent("view-model-changed", {detail: {value: compositionStr, path: 'viewModel.' + notificationPath}}));
        };

        // stringToDocumentFragment(strHTML) from http://stackoverflow.com/a/25214113/868184
        /**
         * Creates DocumentFragment from a string.
         * @param  {string} htmlStr  string to parse
         * @param  {HTMLElement} node node to select a range, need for Safari workaround
         * @return {DocumentFragment}      parsed string
         */
        StarcounterIncludePrototype.stringToDocumentFragment = function (htmlStr) {
            var range = document.createRange();
            // Safari does not support `createContextualFragment` without selecting a node.
            if (isSafari) {
                range.selectNode(this);
            }
            return range.createContextualFragment(htmlStr);
        }

        /**
         * Find composition provider scope in given marged/namespaced view-model
         * @param  {Object} obj namespaced view-model
         * @return {Object}     Composition Provider scope
         */
        function findCompositionProvider(obj) {
            return obj.CompositionProvider || obj.CompositionProvider_0;
        };
        /**
         * Find composition provider path in given marged/namespaced view-model
         * @param  {Object} obj namespaced view-model
         * @return {String}     path to Composition Provider scope
         */
        function findCompositionProviderPath(obj) {
            return obj.CompositionProvider && 'CompositionProvider'|| obj.CompositionProvider_0 && 'CompositionProvider_0';
        };

        /**
         * Check if given viewModel is non-namespace (contains `.Html` property)
         * and throw a warning to the console with a hint how to fix that.
         * @param  {Object} viewModel view-model to check
         * @param  {HTMLElement} element starcounter-include to point to
         */
        function checkForNonNamespaced(viewModel, element){
            if(viewModel && typeof viewModel.Html !== 'undefined'){
                console.warn(`Your view-model is probably not namespaced!
`, viewModel, `
We no longer support those.
Please make sure it's a result of \`Self.GET\` on serverside. If it's not a result of blending, then replace \`<starcounter-include view-model="{{viewModel}}">\` with  \`<div><template is="imported-template" model="{{viewModel}}" href="{{viewModel.Html}}"></template></div>\`.
`, element);
            }
        };

        /**
         * Stamps new shadow root (overwrites existing),
         * translates between V1 and V0
         * @fires stamped
         * @param {DocumentFragment} givenComposition
         */
        StarcounterIncludePrototype.stampComposition = function(givenComposition){
            // console.log('stamp', this.partialId, this);
            // document.importNode(givenComposition, true);
            // create shadowRoot if none
            const shadowRoot = this.shadowRoot;

            if (givenComposition !== undefined) {
                // reset SD to default CSS
                shadowRoot.innerHTML = '';
                if(useShadowDOMV1){
                    // translate givenComposition to current version of SD
                    TranslateShadowDOM.v0tov1.fragment(givenComposition, true);
                } else {
                    // translate givenComposition to current version of SD
                    TranslateShadowDOM.v1tov0.fragment(givenComposition, true);
                }

                var elems = givenComposition.querySelectorAll("content:not([select])");
                Array.prototype.forEach.call(elems, (elem) => elem.setAttribute("select", ":not([slot]),[slot='']")); //workaround for https://github.com/tomalec/Translate-ShadowDOM/issues/3

                shadowRoot.appendChild(givenComposition);
                // polyfill `polyfill-next-selector` if needed
                typeof WebComponents !== 'undefined' && WebComponents.ShadowCSS &&
                    WebComponents.ShadowCSS.replaceTextInStyles(
                        WebComponents.ShadowCSS.findStyles(shadowRoot),
                        WebComponents.ShadowCSS.insertDirectives
                    );
            } else if(shadowRoot){
                shadowRoot.innerHTML = defaultShadowCSS + defaultShadowDOM;
            }
            this.dispatchEvent(new CustomEvent("stamped"));
        }

        StarcounterIncludePrototype.clear = function (){
            console.error('clear is not yet defined!');
        }


        document.registerElement('starcounter-include', StarcounterInclude);
    })();
</script>
