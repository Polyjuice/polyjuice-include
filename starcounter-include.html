<!--
`starcounter-include` -
Custom Element (w/ Polymer's TemplateBinding)
with predefined template content, which should be used to include partials.
It's just <template is="imported-template"> wrapped within Shadow Root for `declarative-shadow-dom` bindable by layout editor.
Uses Shadow DOM given from DB as `Starcounter.MergedPartial.(CompositionProvider|CompositionProvider_0).Composition$`.
version: 3.0.0-rc.6

-->
<!-- Import dependencies -->
<link rel="import" href="../imported-template/imported-template.html">
<link rel="import" href="../translate-shadowdom/translate-shadowdom.html">
<!-- <link rel="import" href="/sys/console-log/console-log.html"> -->

<script>
    (function() {
        const useShadowDOMV1 = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);
        // && !(window.StarcounterInclude && window.StarcounterInclude.shadow === 'v0'));
        const defaultShadowCSS = '<style>:host{display:block;}</style>';
        const defaultShadowDOM = useShadowDOMV1 ? '<slot></slot>' : '<content></content>';


        const isSafari = navigator.vendor && navigator.vendor.indexOf("Apple") > -1 && navigator.userAgent && !navigator.userAgent.match("CriOS");

        class StarcounterInclude extends HTMLElement {
            // static get shadow(){
            //     return useShadowDOMV1;
            // }
            static get observedAttributes() {
                return ['partial', 'view-model', 'partialId'];
            }
            // the self argument might be provided or not
            // in both cases, the mandatory `super()` call
            // will return the right context/instance to use
            // and eventually return
            constructor(self) {
                self = super(self);
                self.created();
                return self;
            }
            /**
             * Stamp `imported-template` into Light DOM,
             * attach `stamping` listener to gather Shadow DOM layout compositions
             * (declarative-shadow-dom)
             */
            stampImportedTemplate(){
                if(!this.template){
                    const starcounterInclude = this;
                    const importedTemplate = document.createElement('template', 'imported-template');

                    var href = buildURL(this.partial, this.mergedHtmlPrefix, this.defaultHtml);

                    importedTemplate.addEventListener('stamping', function fetchCompositions(event) {
                        var mergedComposition;
                        var templates = event.detail.querySelectorAll('template[is="declarative-shadow-dom"],template[is="starcounter-composition"]');
                        if(templates.length){
                            mergedComposition = document.createDocumentFragment()
                            Array.prototype.forEach.call(templates, function mergeContents(individualComposition) {
                                if(individualComposition.getAttribute('is') === 'starcounter-composition'){
                                    console.warn('`starcounter-composition` was renamed to `declarative-shadow-dom`! Please update your markup, as the old name is likely to be not supported soon (in V1).')
                                }
                                mergedComposition.appendChild(individualComposition.content);
                            });
                        }
                        starcounterInclude.defaultComposition = mergedComposition;

                        if (this.model != starcounterInclude.partial) {
                            this.model = starcounterInclude.partial
                        }
                        // notify composition property
                        // TODO: consider moving entire partialChanged or appendChild here
                        starcounterInclude._compositionChanged();
                    });
                    href && (importedTemplate.href = href);


                    this.appendChild(importedTemplate);
                    this.template = importedTemplate;
                }
            }
            connectedCallback(){
                this.stampImportedTemplate();
            }
        }
        var StarcounterIncludePrototype = StarcounterInclude.prototype;
        StarcounterIncludePrototype.shadow = useShadowDOMV1;
        StarcounterIncludePrototype.partial = null;
        StarcounterIncludePrototype.partialId = null;
        //FIXME: this one should not be needed, once we get rid of workarounds for server-side
        StarcounterIncludePrototype.compositionAPI = '/sc/partial/composition';
        // StarcounterIncludePrototype.href = null;
        StarcounterIncludePrototype.mergedHtmlPrefix = '/sc/htmlmerger?';
        StarcounterIncludePrototype.defaultHtml = '';
        /**
         * @see Starcounter/starcounter-include - partialAttributeToProperty It's just a copy
         */
        function partialAttributeToProperty(element, attrVal) {

            var attrVal = element.getAttribute("partial") || element.getAttribute("view-model");
            if(!attrVal){
                // no value
                return undefined;
            } else if (attrVal.match(/\{\{.*\}\}|\[\[.*\]\]/)) {
                return null;
            } else {
                return JSON.parse(attrVal);
            }
        }
        /**
         * Create shadowRoot, define property setters, set unitial partial.
         */
        StarcounterIncludePrototype.created = function StarcounterIncludeCreated() {
            var starcounterInclude = this;
            var partialId = this.partialId;
            var partial = this.viewModel || this.partial || undefined;
            checkForNonNamesapced(partial, this);

            // build shadow DOM
            if(useShadowDOMV1){
                this.attachShadow({mode: "open"});
            } else {
                this.createShadowRoot();
            }
            // partialChanged will do
            // this.stampComposition();

            // define a setter for partial attribute,
            // so it could be change by VanillaJs without Polymer Template Binding
            Object.defineProperties(this, {
                partial: {
                    set: function(newValue) {
                        partial = newValue;
                        checkForNonNamesapced(partial, this);
                        starcounterInclude.stampImportedTemplate();
                        starcounterInclude.partialChanged(partial);
                    },
                    get: function() {
                        return partial;
                    }
                },
                viewModel: {
                    set: function(newValue) {
                        this.partial = newValue;
                    },
                    get: function() {
                        return this.partial;
                    }
                },
                partialId: {
                    set: function(newValue) {
                        // do nothing if value is the same or null is being changed to undefined
                        if (newValue != partialId) {
                            partialId = newValue || null;
                            if (!partialId) {
                                this.removeAttribute("partial-id");
                            } else {
                                this.setAttribute("partial-id", partialId);
                            }
                        }
                    },
                    get: function() {
                        return partialId;
                    }
                }
            });
            // attach partial
            this.partialChanged();
        };
        /**
         * Set partial property if partial or viewm-model attribute was changed
         */
        StarcounterIncludePrototype.attributeChangedCallback = function(name, oldVal, newVal) {
            if (name === "partial" || name === "view-model") {
                this.partial = partialAttributeToProperty(this, newVal);
                //d console.log("starcounter-partial attr changed");
            }
        };
        /**
         * Updates inner `imported-template` with partial data given (if applicable)
         * @see Starcounter/starcounter-include#partialChanged it's alsmost a copy
         * @param  {Object} newVal new partial value
         */
        StarcounterIncludePrototype.partialChanged = function(newVal) {
            this._htmlChanged();
            this._compositionChanged();
        };
        StarcounterIncludePrototype._htmlChanged = function() {
            // do nothing if there is no tempalte yet
            if(!this.template){
                return;
            }
            var href = buildURL(this.partial, this.mergedHtmlPrefix, this.defaultHtml);
            if (href !== this._lastHref) {
                if (this._lastHref) {
                    this.template.clear();
                }
                if (!href) {
                    this.template.href = null;
                    if (this.template.model != this.partial) {
                        this.template.model = this.partial
                    }
                } else {
                    this.template.href = href;
                }
                this._forceLayoutChange = true;
                this._lastHref = href;
            } else if (this.template.model != this.partial) {
                this.template.model = this.partial
            }
        };

        /**
         * Stamps composition if needed
         * @param  {String|DocumentFragment} compositionRef reference to the evaluated composition
         * @param  {Function} callb Function that returns a composition to render
         */
        StarcounterIncludePrototype._renderCompositionChange = function(compositionRef, callb) {
            if (!this._forceLayoutChange && this._lastCompositionRef == compositionRef) {
                return;
            }
            let composition = callb();
            this.stampComposition(composition);
            this._forceLayoutChange = false;
            this._lastCompositionRef = compositionRef;
        }

        /**
         * Handles change of the composition.
         * If not given explicitely, fetches one from provider.
         * If not given in provider, fetches one from imported template's default composition.
         * If imported template does not have a default composition, uses fallback composition.
         * Warning: the explicit composition might come from https://github.com/Starcounter/starcounter-layout-html-editor/blob/17b21f729facd9a8dcd4241fb5c48cb71de11af5/starcounter-layout-html-editor.html#L253
         * @see .stampComposition
         * @param  {String} compositionString stringified HTML for new Shadow Root
         */
        StarcounterIncludePrototype._compositionChanged = function(compositionString) {
            var that = this;

            if (compositionString !== undefined) {
                this._forceLayoutChange = true;
                this._renderCompositionChange("explicit or fallback", function() {
                    return that.stringToDocumentFragment(compositionString);
                });
            }
            else {
                const compositionProvider = this.partial && findCompositionProvider(this.partial);
                this.partialId = compositionProvider && compositionProvider.PartialId;

                if (compositionProvider && compositionProvider.Composition$) {
                    this._renderCompositionChange(compositionProvider.Composition$, function() {
                        that.storedLayout = compositionProvider.Composition$; //should always be string
                        return that.stringToDocumentFragment(that.storedLayout);
                    });
                }
                else if (this.defaultComposition) {
                    this._renderCompositionChange(this.defaultComposition, function() {
                        return that.defaultComposition.cloneNode(true);
                    });
                }
                else {
                    this._renderCompositionChange("explicit or fallback", function() {
                        return undefined;
                    });
                }
            }            
        };
        /**
         * Forward Polymer notification downwards from `<template is="dom-bind">`
         * to <template is="imported-template">
         * @param  {String} path Polymer notification path
         * @param  {Mixed} value New value
         */
        StarcounterIncludePrototype._notifyPath = function(path, value) {
            var sameModelAlreadyLoaded = this.template.model == this.partial;
            this.partialChanged(this.partial);
            if (sameModelAlreadyLoaded && this.template._notifyPath) {
                this.template._notifyPath(
                    path.replace("partial.", "model.")
                        .replace("viewModel.", "model."),
                     value);
            }
        };
        /**
         * Retrieves URL of HTML file to be loaded from given partial.
         * For merged partials/namespaced JSONs without
         * `.Html` property on root level it builds one out of
         * `.Html` properties from nested objects
         * {prefix}{key1}={partial.key1.Html}&{key2}={partial.key2.Html}&{key3}={defaultURL}
         * Parameters are URI encoded, for scopes without `.Html` property _defaultURL_ is used
         * @param  {Object} partial    partial object
         * @param  {String} prefix     prefix for merged partials
         * @param  {String} defaultURL Html to be used for nodes that does not have one
         * @return {String}            [description]
         */
        function buildURL(partial, prefix, defaultURL) {
            if(partial){
                if(partial.Html !== undefined){
                    return partial.Html;
                } else {
                    var htmls = [];
                    for (var key in partial){
                        if (partial.hasOwnProperty(key)) {
                            // quick fix for https://github.com/Starcounter/starcounter-include/issues/37
                            // just to unblock https://github.com/Starcounter/level1/issues/4061
                            if (key !== '_ver#s' && key !== '_ver#c$') {
                                htmls.push(
                                    encodeURIComponent(key) +
                                    '=' +
                                    (partial[key].Html && encodeURIComponent(partial[key].Html) || defaultURL)
                                );
                            }
                        }
                    }
                    // Workaround for https://github.com/Starcounter/Starcounter/issues/3072
                    // as described in https://github.com/Starcounter/starcounter-include/issues/12
                    return htmls.length && (prefix + htmls.join('&')) || undefined;
                    // return prefix + htmls.join('&');
                }
            } else {
                return undefined;
            }
        };
        /**
         * Saves given or current composition as stored one, (TODO:) notifies binding about it.
         * @param  {String} [compositionStr] composition to be saved, if not given current one will be used
         * @TODO: to be simplified after https://github.com/StarcounterApps/CompositionProvider/pull/13 is done
         */
        StarcounterIncludePrototype.saveLayout = function(compositionStr){
            compositionStr = compositionStr || this.shadowRoot.innerHTML;
            this.storedLayout = compositionStr;
            //TODO: trigger polymer-protocol-compliant event

            // FIXME: temporary workaround for servers not accepting JSON-Patch
            // from juicy-tiles-setup-sync
            var req = new XMLHttpRequest();
            req.open("POST", this.compositionAPI + "?key=" + encodeURIComponent(this.partialId) + '&ver=', true);
            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    if (!(req.status >= 200 && req.status <= 299)) {
                        console.error("Failed to save composition configuration");
                        return;
                    }
                    console.info("composition configuration saved");
                }
                // FIXME: bellow is required for save button not to overwrite with old value, but it fails due to puppet error
                console.info('Direct change to model is required for save button not to overwrite with old value, but it fails due to puppet error.');
                findCompositionProvider(this.partial).Composition$ = this.storedLayout;
                this.dispatchEvent(new CustomEvent("starcounter-include-composition-saved", {detail: this.storedLayout}));
                // trigger polymer-notification-protocol-compilant event
                this.dispatchEvent(new CustomEvent("partial-changed", {detail: {value: this.storedLayout, path: 'partial.' + findCompositionProviderPath(this.partial) + '.Composition$'}}));
                this.dispatchEvent(new CustomEvent("view-model-changed", {detail: {value: this.storedLayout, path: 'viewModel.' + findCompositionProviderPath(this.partial) + '.Composition$'}}));
            }.bind(this);
            return req.send(this.storedLayout);

        };

        // stringToDocumentFragment(strHTML) from http://stackoverflow.com/a/25214113/868184
        /**
         * Creates DocumentFragment from a string.
         * @param  {string} htmlStr  string to parse
         * @param  {HTMLElement} node node to select a range, need for Safari workaround
         * @return {DocumentFragment}      parsed string
         */
        StarcounterIncludePrototype.stringToDocumentFragment = function (htmlStr) {
            var range = document.createRange();
            // Safari does not support `createContextualFragment` without selecting a node.
            if (isSafari) {
                range.selectNode(this);
            }
            return range.createContextualFragment(htmlStr);
        }

        /**
         * Find composition provider scope in given marged/namespaced view-model
         * @param  {Object} obj namespaced view-model
         * @return {Object}     Composition Provider scope
         */
        function findCompositionProvider(obj) {
            return obj.CompositionProvider || obj.CompositionProvider_0;
        };
        /**
         * Find composition provider path in given marged/namespaced view-model
         * @param  {Object} obj namespaced view-model
         * @return {String}     path to Composition Provider scope
         */
        function findCompositionProviderPath(obj) {
            return obj.CompositionProvider && 'CompositionProvider'|| obj.CompositionProvider_0 && 'CompositionProvider_0';
        };

        /**
         * Check if given viewModel is non-namespace (contains `.Html` property)
         * and throw a warning to the console with a hint how to fix that.
         * @param  {Object} viewModel view-model to check
         * @param  {HTMLElement} element starcounter-include to point to
         */
        function checkForNonNamesapced(viewModel, element){
            if(viewModel && typeof viewModel.Html !== 'undefined'){
                console.warn(`Your view-model is probably not namespaced!
`, viewModel, `
We no longer support those.
Please make sure it's a result of \`Self.GET\` on serverside. If it's not a result of blending, then replace \`<starcounter-include view-model="{{viewModel}}">\` with  \`<div><template is="imported-template" model="{{viewModel}}" href="{{viewModel.Html}}"></template></div>\`.
`, element);
            }
        };

        /**
         * Stamps new shadow root (overwrites existing),
         * translates between V1 and V0
         * @fires stamped
         * @param {DocumentFragment} givenComposition
         */
        StarcounterIncludePrototype.stampComposition = function(givenComposition){
            // console.log('stamp', this.partialId, this);
            // document.importNode(givenComposition, true);
            // create shadowRoot if none
            const shadowRoot = this.shadowRoot;

            if (givenComposition) {
                // reset SD to default CSS
                shadowRoot.innerHTML = '';
                if(useShadowDOMV1){
                    // translate givenComposition to current version of SD
                    TranslateShadowDOM.v0tov1.fragment(givenComposition, true);
                } else {
                    // translate givenComposition to current version of SD
                    TranslateShadowDOM.v1tov0.fragment(givenComposition, true);
                }

                shadowRoot.appendChild(givenComposition);
                // polyfill `polyfill-next-selector` if needed
                WebComponents && WebComponents.ShadowCSS &&
                    WebComponents.ShadowCSS.replaceTextInStyles(
                        WebComponents.ShadowCSS.findStyles(shadowRoot),
                        WebComponents.ShadowCSS.insertDirectives
                    );
                this.isStamped = true;
            } else if(shadowRoot){
                shadowRoot.innerHTML = defaultShadowCSS + defaultShadowDOM;
            }
            this.dispatchEvent(new CustomEvent("stamped"));
        }

        StarcounterIncludePrototype.clear = function (){
            console.error('clear is not yet defined!');
        }


        customElements.define('starcounter-include', StarcounterInclude);
    })();
</script>
