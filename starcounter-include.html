<!--
`starcounter-include` -
Custom Element (w/ Polymer's TemplateBinding)
with predefined template content, which should be used to include partials.
It's just <template is="imported-template"> wrapped within Shadow Root for `declarative-shadow-dom` bindable by layout editor.
Uses Shadow DOM given from DB as `Starcounter.MergedPartial.(CompositionProvider|CompositionProvider_0).Composition$`.
version: 3.0.0-rc.2

-->
<!-- Import dependencies -->
<link rel="import" href="../imported-template/imported-template.html">
<link rel="import" href="../translate-shadowdom/translate-shadowdom.html">
<!-- <link rel="import" href="/sys/console-log/console-log.html"> -->

<script>
    (function() {
        const useShadowDOMV1 = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);
        // && !(window.StarcounterInclude && window.StarcounterInclude.shadow === 'v0'));
        const defaultShadowCSS = '<style>:host{display:block;}</style>';
        const defaultShadowDOM = useShadowDOMV1 ? '<slot></slot>' : '<content></content>';


        const isSafari = navigator.vendor && navigator.vendor.indexOf("Apple") > -1 && navigator.userAgent && !navigator.userAgent.match("CriOS");

        class StarcounterInclude extends HTMLElement {
            // static get shadow(){
            //     return useShadowDOMV1;
            // }
            static get observedAttributes() {
                return ['partial', 'view-model', 'partialId'];
            }
            // the self argument might be provided or not
            // in both cases, the mandatory `super()` call
            // will return the right context/instance to use
            // and eventually return
            constructor(self) {
                self = super(self);
                self.created();
                return self;
            }
            /**
             * Stamp `imported-template` into Light DOM,
             * attach `stamping` listener to gather Shadow DOM layout compositions
             * (declarative-shadow-dom)
             */
            stampImportedTemplate(){
                if(!this.template){
                    const starcounterInclude = this;
                    const importedTemplate = document.createElement('template', 'imported-template');

                    var html = buildURL(this.partial, this.mergedHtmlPrefix, this.defaultHtml);

                    importedTemplate.addEventListener('stamping', function fetchCompositions(event) {
                        var mergedComposition;
                        var templates = event.detail.querySelectorAll('template[is="declarative-shadow-dom"],template[is="starcounter-composition"]');
                        if(templates.length){
                            mergedComposition = document.createDocumentFragment()
                            Array.prototype.forEach.call(templates, function mergeContents(individualComposition) {
                                if(individualComposition.getAttribute('is') === 'starcounter-composition'){
                                    console.warn('`starcounter-composition` was renamed to `declarative-shadow-dom`! Please update your markup, as the old name is likely to be not supported soon (in V1).')
                                }
                                mergedComposition.appendChild(individualComposition.content);
                            });
                        }
                        starcounterInclude.defaultComposition = mergedComposition;

                        if (this.model != starcounterInclude.partial) {
                            this.model = starcounterInclude.partial
                        }
                        // notify composition property
                        // TODO: consider moving entire partialChanged or appendChild here
                        starcounterInclude._compositionChanged();
                    });
                    html && importedTemplate.setAttribute('content', html);


                    this.appendChild(importedTemplate);
                    this.template = importedTemplate;
                }
            }
            connectedCallback(){
                this.stampImportedTemplate();
            }
        }
        var StarcounterIncludePrototype = StarcounterInclude.prototype;
        StarcounterIncludePrototype.shadow = useShadowDOMV1;
        StarcounterIncludePrototype.partial = null;
        StarcounterIncludePrototype.partialId = null;
        //FIXME: this one should not be needed, once we get rid of workarounds for server-side
        StarcounterIncludePrototype.compositionAPI = '/sc/partial/composition';
        // StarcounterIncludePrototype.html = null;
        StarcounterIncludePrototype.mergedHtmlPrefix = '/sc/htmlmerger?';
        StarcounterIncludePrototype.defaultHtml = '';
        /**
         * @see Starcounter/starcounter-include - partialAttributeToProperty It's just a copy
         */
        function partialAttributeToProperty(element, attrVal) {
            var attrVal = element.getAttribute("partial") || element.getAttribute("view-model");
            if(!attrVal){
                // no value
                return undefined;
            } else if (attrVal.match(/\{\{.*\}\}|\[\[.*\]\]/)) {
                return null;
            } else {
                return JSON.parse(attrVal);
            }
        }
        /**
         * Create shadowRoot, define property setters, set unitial partial.
         */
        StarcounterIncludePrototype.created = function StarcounterIncludeCreated() {
            var starcounterInclude = this;
            var partialId = this.partialId;
            var partial = this.viewModel || this.partial || undefined;

            // build shadow DOM
            if(useShadowDOMV1){
                this.attachShadow({mode: "open"});
            } else {
                this.createShadowRoot();
            }
            // partialChanged will do
            // this.stampComposition();

            // define a setter for partial attribute,
            // so it could be change by VanillaJs without Polymer Template Binding
            Object.defineProperties(this, {
                partial: {
                    set: function(newValue) {
                        partial = newValue;
                        starcounterInclude.stampImportedTemplate();
                        starcounterInclude.partialChanged(partial);
                    },
                    get: function() {
                        return partial;
                    }
                },
                viewModel: {
                    set: function(newValue) {
                        this.partial = newValue;
                    },
                    get: function() {
                        return this.partial;
                    }
                },
                partialId: {
                    set: function(newValue) {
                        // do nothing if value is the same or null is being changed to undefined
                        if (newValue != partialId) {
                            partialId = newValue || null;
                            if (!partialId) {
                                this.removeAttribute("partial-id");
                            } else {
                                this.setAttribute("partial-id", partialId);
                            }
                        }
                    },
                    get: function() {
                        return partialId;
                    }
                }
            });
            // attach partial
            this.partialChanged();
        };
        /**
         * Set partial property if partial or viewm-model attribute was changed
         */
        StarcounterIncludePrototype.attributeChangedCallback = function(name, oldVal, newVal) {
            if (name === "partial" || name === "view-model") {
                this.partial = partialAttributeToProperty(this, newVal);
                //d console.log("starcounter-partial attr changed");
            }
        };
        /**
         * Updates inner `imported-template` with partial data given (if applicable)
         * @see Starcounter/starcounter-include#partialChanged it's alsmost a copy
         * @param  {Object} newVal new partial value
         */
        StarcounterIncludePrototype.partialChanged = function(newVal) {
            this._htmlChanged();
            const compositionProvider = this.partial && findCompositionProvider(this.partial);
            this.partialId = compositionProvider && compositionProvider.PartialId; //should always be string
            this._compositionChanged();
        };
        StarcounterIncludePrototype._htmlChanged = function() {
            // do nothing if there is no tempalte yet
            if(!this.template){
                return;
            }
            var html = buildURL(this.partial, this.mergedHtmlPrefix, this.defaultHtml);
            if (html !== this._lastHtml) {
                if (this._lastHtml) {
                    this.template.clear();
                }
                if (!html) {
                    this.template.removeAttribute("content");
                    if (this.template.model != this.partial) {
                        this.template.model = this.partial
                    }
                } else {
                    this.template.setAttribute("content", html);
                }
                this._forceLayoutChange = true;
                this._lastHtml = html;
            } else if (this.template.model != this.partial) {
                this.template.model = this.partial
            }
        };
        /**
         * Handles change of the composition.
         * If not given explicitely, fetches one from provider.
         * Stamps if needed.
         * @see .stampComposition
         * @param  {String} compositionString stringified HTML for new Shadow Root
         */
        StarcounterIncludePrototype._compositionChanged = function(compositionString) {
            let composition;
            if (this.partial && compositionString === undefined) {
                const compositionProvider = findCompositionProvider(this.partial);
                if (compositionProvider) {
                    compositionString = compositionProvider.Composition$; //should always be string
                    this.storedLayout = compositionString;
                }
            }
            // do not change if there is one, it's same as before, and we are not forced
            if (!compositionString || compositionString !== this._lastLayout || this._forceLayoutChange) {
                if (!compositionString) {
                    composition = this.defaultComposition && this.defaultComposition.cloneNode(true);
                } else {
                    // make clone to avoid direct binding
                    composition = this.stringToDocumentFragment(compositionString);
                }
                this.stampComposition(composition);
                this._forceLayoutChange = false;
                this._lastLayout = compositionString;
            }
        };
        /**
         * Forward Polymer notification downwards from `<template is="dom-bind">`
         * to <template is="imported-template">
         * @param  {String} path Polymer notification path
         * @param  {Mixed} value New value
         */
        StarcounterIncludePrototype._notifyPath = function(path, value) {
            if (path.indexOf("partial.") === 0 || path.indexOf("viewModel.") === 0) {
                if (
                    // path === "viewModel.Html" || // covered by  viewModel._whatever_
                    // path.match(/^viewModel\.[^.]+\.Html$/)
                    (path.indexOf('.Html') === path.length - 5) && path.slice(10, -5).indexOf('.') === -1
                ) {
                    this.partialChanged(this.partial);
                } else if (
                    // path === "partial.Html" || // covered by  partial._whatever_
                    // path.match(/^partial\.[^.]+\.Html$/)
                    (path.indexOf('.Html') === path.length - 5) && path.slice(8, -5).indexOf('.') === -1
                ) {
                    this.partialChanged(this.partial);
                } else if(
                    // if viewModel|partial._whatever_, but not _ver - scope changed
                    path.split('.').length === 2 && path.indexOf('_ver#s') === -1 && path.indexOf('_ver#c$') === -1
                ){
                    this.partialChanged(this.partial);
                } else {
                    const compositionProviderPath = findCompositionProviderPath(this.partial);
                    // if (path === 'partial.' + compositionProviderPath ||
                    //     path === 'viewModel.' + compositionProviderPath) {
                    //     // .Composition$ and .PartialId may have changed, also CompositionProvider theoretically could provide it's .Html as well
                    //     this.partialChanged();
                    // } else
                    if(
                        // .Composition$ have changed
                        path === 'partial.' + compositionProviderPath  + '.Composition$'||
                        path === 'viewModel.' + compositionProviderPath + '.Composition$'
                    ) {
                        this._compositionChanged();
                    } else if (path === 'partial.' + compositionProviderPath + '.PartialId' || path === 'viewModel.' + compositionProviderPath + '.PartialId') {
                        const compositionProvider = findCompositionProvider(this.partial);
                        this.partialId = compositionProvider && compositionProvider.PartialId; //should always be string
                    } else if (this.template._notifyPath) {
                        this.template._notifyPath(
                            path.replace("partial.", "model.")
                                .replace("viewModel.", "model."),
                             value);
                    }
                }
            }
        };
        /**
         * Retrieves URL of HTML file to be loaded from given partial.
         * For merged partials/namespaced JSONs without
         * `.Html` property on root level it builds one out of
         * `.Html` properties from nested objects
         * {prefix}{key1}={partial.key1.Html}&{key2}={partial.key2.Html}&{key3}={defaultURL}
         * Parameters are URI encoded, for scopes without `.Html` property _defaultURL_ is used
         * @param  {Object} partial    partial object
         * @param  {String} prefix     prefix for merged partials
         * @param  {String} defaultURL Html to be used for nodes that does not have one
         * @return {String}            [description]
         */
        function buildURL(partial, prefix, defaultURL) {
            if(partial){
                if(partial.Html !== undefined){
                    return partial.Html;
                } else {
                    var htmls = [];
                    for (var key in partial){
                        if (partial.hasOwnProperty(key)) {
                            // quick fix for https://github.com/Starcounter/starcounter-include/issues/37
                            // just to unblock https://github.com/Starcounter/level1/issues/4061
                            if (key !== '_ver#s' && key !== '_ver#c$') {
                                htmls.push(
                                    encodeURIComponent(key) +
                                    '=' +
                                    (partial[key].Html && encodeURIComponent(partial[key].Html) || defaultURL)
                                );
                            }
                        }
                    }
                    // Workaround for https://github.com/Starcounter/Starcounter/issues/3072
                    // as described in https://github.com/Starcounter/starcounter-include/issues/12
                    return htmls.length && (prefix + htmls.join('&')) || undefined;
                    // return prefix + htmls.join('&');
                }
            } else {
                return undefined;
            }
        };
        /**
         * Saves given or current composition as stored one, (TODO:) notifies binding about it.
         * @param  {String} [compositionStr] composition to be saved, if not given current one will be used
         * @TODO: to be simplified after https://github.com/StarcounterApps/CompositionProvider/pull/13 is done
         */
        StarcounterIncludePrototype.saveLayout = function(compositionStr){
            compositionStr = compositionStr || this.shadowRoot.innerHTML;
            this.storedLayout = compositionStr;
            //TODO: trigger polymer-protocol-compliant event

            // FIXME: temporary workaround for servers not accepting JSON-Patch
            // from juicy-tiles-setup-sync
            var req = new XMLHttpRequest();
            req.open("POST", this.compositionAPI + "?key=" + encodeURIComponent(this.partialId) + '&ver=', true);
            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    if (!(req.status >= 200 && req.status <= 299)) {
                        console.error("Failed to save composition configuration");
                        return;
                    }
                    console.info("composition configuration saved");
                }
                // FIXME: bellow is required for save button not to overwrite with old value, but it fails due to puppet error
                console.info('Direct change to model is required for save button not to overwrite with old value, but it fails due to puppet error.');
                findCompositionProvider(this.partial).Composition$ = this.storedLayout;
                this.dispatchEvent(new CustomEvent("starcounter-include-composition-saved", {detail: this.storedLayout}));
                // trigger polymer-notification-protocol-compilant event
                this.dispatchEvent(new CustomEvent("partial-changed", {detail: {value: this.storedLayout, path: 'partial.' + findCompositionProviderPath(this.partial) + '.Composition$'}}));
                this.dispatchEvent(new CustomEvent("view-model-changed", {detail: {value: this.storedLayout, path: 'viewModel.' + findCompositionProviderPath(this.partial) + '.Composition$'}}));
            }.bind(this);
            return req.send(this.storedLayout);

        };

        // stringToDocumentFragment(strHTML) from http://stackoverflow.com/a/25214113/868184
        /**
         * Creates DocumentFragment from a string.
         * @param  {string} htmlStr  string to parse
         * @param  {HTMLElement} node node to select a range, need for Safari workaround
         * @return {DocumentFragment}      parsed string
         */
        StarcounterIncludePrototype.stringToDocumentFragment = function (htmlStr) {
            var range = document.createRange();
            // Safari does not support `createContextualFragment` without selecting a node.
            if (isSafari) {
                range.selectNode(this);
            }
            return range.createContextualFragment(htmlStr);
        }

        /**
         * Find composition provider scope in given marged/namespaced view-model
         * @param  {Object} obj namespaced view-model
         * @return {Object}     Composition Provider scope
         */
        function findCompositionProvider(obj) {
            return obj.CompositionProvider || obj.CompositionProvider_0;
        };
        /**
         * Find composition provider path in given marged/namespaced view-model
         * @param  {Object} obj namespaced view-model
         * @return {String}     path to Composition Provider scope
         */
        function findCompositionProviderPath(obj) {
            return obj.CompositionProvider && 'CompositionProvider'|| obj.CompositionProvider_0 && 'CompositionProvider_0';
        };


        /**
         * Stamps new shadow root (overwrites existing),
         * translates between V1 and V0
         * @fires stamped
         * @param {DocumentFragment} givenComposition
         */
        StarcounterIncludePrototype.stampComposition = function(givenComposition){
            // console.log('stamp', this.partialId, this);
            // document.importNode(givenComposition, true);
            // create shadowRoot if none
            const shadowRoot = this.shadowRoot;

            if (givenComposition) {
                // reset SD to default CSS
                shadowRoot.innerHTML = '';
                if(useShadowDOMV1){
                    // translate givenComposition to current version of SD
                    TranslateShadowDOM.v0tov1.fragment(givenComposition, true);
                } else {
                    // translate givenComposition to current version of SD
                    TranslateShadowDOM.v1tov0.fragment(givenComposition, true);
                }

                shadowRoot.appendChild(givenComposition);
                // polyfill `polyfill-next-selector` if needed
                WebComponents && WebComponents.ShadowCSS &&
                    WebComponents.ShadowCSS.replaceTextInStyles(
                        WebComponents.ShadowCSS.findStyles(shadowRoot),
                        WebComponents.ShadowCSS.insertDirectives
                    );
                this.isStamped = true;
            } else if(shadowRoot){
                shadowRoot.innerHTML = defaultShadowCSS + defaultShadowDOM;
            }
            this.dispatchEvent(new CustomEvent("stamped"));
        }

        StarcounterIncludePrototype.clear = function (){
            console.error('clear is not yet defined!');
        }


        customElements.define('starcounter-include', StarcounterInclude);
    })();
</script>
